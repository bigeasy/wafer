<!DOCTYPE html>
<html>
  <meta charset="utf-8">
  <title>Wafer</title>
  <link href="https://fonts.googleapis.com/css?family=Cutive+Mono|Sorts+Mill+Goudy|Mate|Oxygen+Mono|Offside|Raleway:400,700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy">
  <link rel="stylesheet" type="text/css" href="css/ascetic.css">
  <link rel="stylesheet" type="text/css" href="css/style.css">
</html>
<body><a href="https://github.com/bigeasy/wafer/"><img style="position: fixed; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
  <div class="container">
    <div class="unit welcome">
      <h1>Wafer</h1>
      <!-- todo: code font is too small for body text font-->
    </div>
    <div class="unit description markdown include" data-file="index.md"><h2 id="typed-log-lines">Typed Log Lines</h2>
<p>Log line looking serialization that preserves type for use in your JavaScript
programs.</p>
<pre><code class="lang-javascript">Wafer.serialize({
    <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;mutate&apos;</span>
    sequence: <span class="hljs-number">1</span>,
    <span class="hljs-attr">tag</span>: [ <span class="hljs-string">&apos;database&apos;</span>, <span class="hljs-string">&apos;insert&apos;</span> ],
    <span class="hljs-attr">status</span>: { <span class="hljs-attr">workers</span>: <span class="hljs-number">24</span>, <span class="hljs-attr">locks</span>: <span class="hljs-number">3</span> },
    <span class="hljs-attr">query</span>: <span class="hljs-string">&apos;upsert(&quot;user&quot;, 1)\nwhere user = 1;&apos;</span>,
    <span class="hljs-attr">json</span>: { <span class="hljs-attr">keys</span>: [ <span class="hljs-string">&apos;user&apos;</span>, <span class="hljs-number">1</span> ] }
})
</code></pre>
<p>Becomes.</p>
<pre><code class="lang-text">name=mutate; n sequence=1; 2 tag; tag=database;, tag=insert;, n status.workers=24; &#x21B5;
    n status.locks=3; query=upsert(&quot;user&quot;, 1)%0awhere user %40 1%30; json={&quot;keys&quot;:[&quot;user&quot;,1]}
</code></pre>
<p>Semi-colon delimited and minimally URL encoded. A bit of cruft to preserve the
type information, but still human readable. UNIX tool chain eats it up.</p>
<pre><code class="lang-console"> % egrep &apos; name=mutate;&apos; out.log
</code></pre>
<h2 id="motivation">Motivation</h2>
<p>Streaming JSON is a fine format for to write the logs. With Node.js close at
hand you can usually find what you&apos;re looking for in line after line of JSON.
You can also use <code>jq</code> to &#x2014; the <code>awk</code> of JSON &#x2014; to find what you&apos;re
looking for.</p>
<p>Logging JSON to <code>syslog</code> however, is horrible way to live. I created Wafer to
flatten out a JSON object just enough to make easy to search using tools
designed for <code>syslog</code> analysis.</p>
<p>With Wafer it&apos;s easy to craft regular expressions such to match log lines such
as <code>/ level=error;/</code>. Yes, this is also simple enough against JSON if you&apos;re
using JavaScript regular expressions. You&apos;d simply say <code>/&quot;level&quot;:&quot;error&quot;/</code>. Not
really that much harder at all.</p>
<p>Here&apos;s where it gets harder. I ran into a logging database that wanted to match
strings supplied as double quoted strings. I found myself writing out queries
with a lot of backticks. The above query against JSON would be expressed
as <code>&quot;\\\&quot;statusCode\\\&quot;:\\\&quot;error\\\&quot;&quot;</code>. Against Wafer the query is
<code>&quot; level=error;&quot;</code>.</p>
<p>That&apos;s why this library exists. It&apos;s supposed to be easy to search with standard
regular expression tools. It&apos;s supposed to be easier for a human to read than
JSON. Let me know if you find a use for it.</p>
<h2 id="type-annotations-sigils-and-other-dingbats">Type Annotations, Sigils and Other Dingbats</h2>
<p>There&apos;s a bit of cruft in a line of Wafer used to preserve type information. You
can see that sequence is a number, so it is annotated with <code>n</code>. <code>tag</code> is an
array, so it&apos;s first element is annotated with the array length, subsequent
elements are delimiated by a semi-colon followed by a comma.</p>
<pre><code class="lang-javascript">Wafer.serialize({ <span class="hljs-attr">key</span>: <span class="hljs-string">&apos;value&apos;</span> }) == <span class="hljs-string">&apos;key=value;&apos;</span>
Wafer.serialize({ <span class="hljs-attr">number</span>: <span class="hljs-number">1.1</span> }) == <span class="hljs-string">&apos;n number=1.1;&apos;</span>
Wafer.serialize({ <span class="hljs-attr">flag</span>: <span class="hljs-literal">true</span> }) == <span class="hljs-string">&apos;b flag=true;&apos;</span>
</code></pre>
<p>Values are delimited by <code>;</code>. Here&apos;s the above all together.</p>
<pre><code class="lang-javascript">Wafer.serialize({ <span class="hljs-attr">key</span>: <span class="hljs-string">&apos;value&apos;</span>, number <span class="hljs-number">1.1</span>, <span class="hljs-attr">flag</span>: <span class="hljs-literal">true</span> }) == <span class="hljs-string">&apos;key=value; n number=1.1; b flag=true;&apos;</span>
</code></pre>
<p>Nested objects are flattened.</p>
<pre><code class="lang-javascript">Wafer.serialize({ <span class="hljs-attr">status</span>: { <span class="hljs-attr">state</span>: <span class="hljs-string">&apos;listening&apos;</span>, connections <span class="hljs-number">3</span> } }) ==
    <span class="hljs-string">&apos;status.state=listening; n status.connections=3;&apos;</span>
</code></pre>
<p>Arrays begin with declaration of the array and it&apos;s length. Elements follow.</p>
<pre><code class="lang-javascript">Wafer.serialize({ <span class="hljs-attr">tag</span>: [ <span class="hljs-string">&apos;database&apos;</span>, <span class="hljs-string">&apos;select&apos;</span> ] }) == <span class="hljs-string">&apos;tag 2; tag=database;, tag=select;,&apos;</span>
</code></pre>
<p>Elements are delimited by a semi-colon followed by a comma to indicate the end
of the element.</p>
<p>The commas will not get in the way of your match patterns. You are able to match
the flattened array values using a simple match pattern that doesn&apos;t have to
account for array index. <code>/ tag=select;/</code> matches regardless of where the
&quot;select&quot; tag is in the array.</p>
<p>TK: The match is unambiguous.</p>
<p>The commas are necessary because an element may have an object and that object
might have multiple properties.</p>
<pre><code class="lang-javascript">Wafer.serialize({ <span class="hljs-attr">array</span>: [{ <span class="hljs-attr">one</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">two</span>: <span class="hljs-number">2</span> }, { <span class="hljs-attr">three</span>: <span class="hljs-number">3</span> }] }) ==
    <span class="hljs-string">&apos;array 2; n one=1; n two=2;, three: 3;,&apos;</span>
</code></pre>
<h2 id="winnow-versus-pinpoint">Winnow versus Pinpoint</h2>
<p>I find there&apos;s a difference between the data I want to search and the data I
want to see. The cursory searches that winnow zillions of log lines down to
relevant log lines are different from the extraction of specific log lines from
relevant log lines.</p>
<p>The tool I&apos;m using will pattern match quickly using string match patterns. From
there you can parse JSON to get more details. However if you have to parse JSON
to extract fields to search across the entire corpus, well, that&apos;s slow.</p>
<p>This is why Wafer is designed to have some fields flat and some fields bundled
up. (What I can probably do is work up some AWK + <code>jq</code> queries to how how they
might work together.)</p>
<h2 id="deeply-nested-nonsense">Deeply Nested Nonsense</h2>
<p>The readability of Wafer breaks down when you nest too deeply, but it still
works for any depth. It is essentially a write log.</p>
<pre><code class="lang-javascript">Wafer.serialize({
    <span class="hljs-attr">object</span>: {
        <span class="hljs-attr">array</span>: [ <span class="hljs-string">&apos;one&apos;</span>, <span class="hljs-number">2</span>, { <span class="hljs-attr">key</span>: [ <span class="hljs-string">&apos;value&apos;</span> ] }, { <span class="hljs-attr">one</span>: <span class="hljs-number">1</span> }, [ <span class="hljs-string">&apos;four&apos;</span> ], <span class="hljs-string">&apos;five&apos;</span> ]
    }
})
</code></pre>
<p>Becomes.</p>
<pre><code class="lang-text">4 object.array; object.array=one;, n object.array=2;, object.array.key=value;,
    n object.array.one=1;, 1 object.array; object.array=four;, object.array=five
</code></pre>
<p>Basically, arrays nested in objects ruin everything. If you really want to dump
a blob of data dump it as JSON using the <code>json</code> property. This property is
serialized as JSON. You&apos;ll have the data if you need it.</p>
</div>
  </div>
  <!-- todo: move into an edify plugin-->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-20388260-3', 'bigeasy.github.io');
    ga('send', 'pageview');
  </script>
</body>
<!-- vim: set ts=2 sw=2 nowrap:-->
